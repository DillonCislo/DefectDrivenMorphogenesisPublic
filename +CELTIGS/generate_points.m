function XY = generate_points( latticeOptions )
%GENERATE_LATTICE_POINTS Generates a point set representing cell centers
%
%   INPUT PARAMETERS:
%
%       latticeOptions:     A struct whose fields control the output
%                           Default values in parenthesis
%
%       - pointSetType: Method used to generate the point set
%           - ('square'), points are distributed on a perfect square
%           lattice
%           - 'noisySquare', points are distributed on a perfecet square
%           lattice with added white Gaussian noise
%           - 'rectangular', points are distributed on a rectangular
%           lattice
%           - 'noisyRectangular', points are distrubted on a rectangular
%           lattice with added white Gaussian noise
%           - 'equilateral', points are distributed on a perfect
%           equilateral triangular lattice
%           - 'noisyEquilateral', points are distributed on a perfect
%           equilateral triangular lattice with added white Gaussian noise
%           - 'triangular', points are distributed on a triangular lattice
%           - 'noisyTriangular', points are distributed on a triangular
%           lattice with added white Gaussian noise
%           - 'random', points are drawn randomly with uniform probability
%           within a bounding box
%           - 'randomMinDist', points are drawn randomly with uniform
%           probability within a bounding box such that no point comes
%           within a minimum distance of any other point
%           - 'randomMinDistDisk', points are drawn randomly with uniform
%           probability within a disk such that no point comes within a
%           minimum distance of any other point
%
%       - xLim: The horizontal bounds of the bounding box of the point set
%       ([-100, 100]) 
%
%       - yLim: The vertical bounds of the bounding box of the point set
%       ([-100, 100])
%
%       - radius: The radius of the disk within which points are sampled
%       for the 'randomMinDistDisk' method (overrides 'xLim' and 'yLim')
%       for the appropriate methods)
%
%       - numRows: The number of rows of points in the lattice (20)
%
%       - numCols: The number of columns of points in the lattice (20)
%
%       - numPoints: The total number of output points (overridden by both
%       'numRows' and 'numCols') (500)
%
%       - sideLength: The side length of a square or equilateral
%       triangular element  or a regular lattice (10)
%
%       - SNR: The signal to noise ratio in dB of the nose added to the
%       lattices. See documentation of 'awgn' (5)
%
%       - minDist: The minimum distance within which random point placement
%       is disallowed. Only used with the 'randomMinDist' point set type
%       (5)
%
%       - maxRandSamples: The maximum number of random samples to draw in
%       each subiteration of the 'randomMinDist' method (30)
%
%       - orientation: Used to specify the orientation of contiguous rows
%       of cells generated by the 'equilateral' and 'noisyEquilateral'
%       methods
%
%   OUTPUT PARAMETERS:
%
%       - XY:    Output point coordinates
%
% by Dillon Cislo 2021/02/05

%--------------------------------------------------------------------------
% Input Processing
%--------------------------------------------------------------------------
if (nargin < 1), latticeOptions = struct(); end

% Check for invalid fields
fieldNames = { 'pointSetType', 'xLim', 'yLim', ...
    'numRows', 'numCols', 'numPoints', 'SNR', 'sideLength', ...
    'minDist', 'maxRandSamples', 'radius', 'orientation' };
assert(all(ismember(fieldnames(latticeOptions), fieldNames)), ...
    'Invalid lattice options supplied');

if isfield(latticeOptions, 'pointSetType')
    allTypes = {'square', 'noisySquare', ...
        'rectangular', 'noisyRectangular', ...
        'equilateral', 'noisyEquilateral', ...
        'triangular', 'noisyTriangular', ...
        'random', 'randomMinDist', 'randomMinDistDisk'};
    assert(ismember(latticeOptions.pointSetType, allTypes), ...
        'Invalid point set type supplied');
else
    latticeOptions.pointSetType = 'rectangular';
end

if isfield(latticeOptions, 'xLim')
    validateattributes(latticeOptions.xLim, {'numeric'}, ...
        {'vector', 'numel', 2, 'finite', 'real'});
    assert(latticeOptions.xLim(1) < latticeOptions.xLim(2), ...
        'Invalid x bounds ordering');
else
    latticeOptions.xLim = [-100 100];
end

if isfield(latticeOptions, 'yLim')
    validateattributes(latticeOptions.yLim, {'numeric'}, ...
        {'vector', 'numel', 2, 'finite', 'real'});
    assert(latticeOptions.yLim(1) < latticeOptions.yLim(2), ...
        'Invalid y bounds ordering');
else
    latticeOptions.yLim = [-100 100];
end

if isfield(latticeOptions, 'radius')
    validateattributes(latticeOptions.radius, {'numeric'}, ...
        {'scalar', 'positive', 'finite', 'real'});
else
    latticeOptions.radius = 100;
end

if strcmpi(latticeOptions.pointSetType, 'randomMinDistDisk')
    latticeOptions.xLim = latticeOptions.radius * [-1 1];
    latticeOptions.yLim = latticeOptions.radius * [-1 1];
end

if isfield(latticeOptions, 'numRows')
    validateattributes(latticeOptions.numRows, {'numeric'}, ...
        {'scalar', 'positive', 'integer', 'finite', 'real'});
else
    latticeOptions.numRows = 20;
end

if isfield(latticeOptions, 'numCols')
    validateattributes(latticeOptions.numCols, {'numeric'}, ...
        {'scalar', 'positive', 'integer', 'finite', 'real'});
else
    latticeOptions.numCols = 20;
end

if isfield(latticeOptions, 'numPoints')
    if ~isinf(latticeOptions.numPoints)
        validateattributes(latticeOptions.numPoints, {'numeric'}, ...
            {'scalar', 'positive', 'integer', 'finite', 'real'});
    else
        assert(~strcmpi(latticeOptions.pointSetType, 'random'), ...
            'Infinite point set invalid for random point generation');
        validateattributes(latticeOptions.numPoints, {'numeric'}, ...
            {'scalar'});
    end
else
    latticeOptions.numPoints = 500;
end

if isfield(latticeOptions, 'sideLength')
    validateattributes(latticeOptions.sideLength, {'numeric'}, ...
        {'scalar', 'positive', 'finite', 'real'});
else
    latticeOptions.sideLength = 10;
end

if isfield(latticeOptions, 'SNR')
    validateattributes(latticeOptions.SNR, {'numeric'}, ...
        {'scalar', 'positive', 'finite', 'real'});
else
    latticeOptions.SNR = 5;
end

if isfield(latticeOptions, 'minDist')
    validateattributes(latticeOptions.minDist, {'numeric'}, ...
        {'scalar', 'positive', 'finite', 'real'});
else
    latticeOptions.minDist = 5;
end

if isfield(latticeOptions, 'maxRandSamples')
    validateattributes(latticeOptions.maxRandSamples, {'numeric'}, ...
        {'scalar', 'positive', 'integer', 'finite', 'real'});
else
    latticeOptions.maxRandSamples = 30;
end

if isfield(latticeOptions, 'orientation')
    orientationTypes = {'horizontal', 'vertical'};
    assert(ismember(latticeOptions.orientation, orientationTypes), ...
        'Invalid equilateral row orientation type supplied');
else
    latticeOptions.orientation = 'vertical';
end

%--------------------------------------------------------------------------
% Generate Point Sets
%--------------------------------------------------------------------------
    
switch latticeOptions.pointSetType
    
    case 'square'
        XY = generate_square_lattice_points( latticeOptions );
        
    case 'noisySquare'
        XY = generate_square_lattice_points( latticeOptions );
        XY = awgn(XY, latticeOptions.SNR);
    
    case 'rectangular' 
        XY = generate_rectangular_lattice_points( latticeOptions );
        
    case 'noisyRectangular' 
        XY = generate_rectangular_lattice_points( latticeOptions );
        XY = awgn(XY, latticeOptions.SNR);
        
    case 'equilateral'
        XY = generate_equilateral_lattice_points( latticeOptions );
        
    case 'noisyEquilateral'
        XY = generate_equilateral_lattice_points( latticeOptions );
        XY = awgn(XY, latticeOptions.SNR);
        
    case 'triangular'
        XY = generate_triangular_lattice_points( latticeOptions );

    case 'noisyTriangular'
        XY = generate_triangular_lattice_points( latticeOptions );
        XY = awgn(XY, latticeOptions.SNR);
        
    case 'random'
        XY = generate_uniform_random_points( latticeOptions );
        
    case 'randomMinDist'
        XY = generate_uniform_random_points_min_dist( latticeOptions );

    case 'randomMinDistDisk'
        XY = generate_uniform_random_points_min_dist_disk( latticeOptions );
end

end

function XY = generate_square_lattice_points( latticeOptions )

xLim = latticeOptions.xLim;
yLim = latticeOptions.yLim;
L = latticeOptions.sideLength;

xGridVec = xLim(1):L:xLim(2);
yGridVec = yLim(1):L:yLim(2);

[X, Y] = meshgrid( xGridVec, yGridVec );

XY = [X(:), Y(:)];

end

function XY = generate_rectangular_lattice_points( latticeOptions )

xLim = latticeOptions.xLim;
yLim = latticeOptions.yLim;
numRows = latticeOptions.numRows; 
numCols = latticeOptions.numCols; 

dx = ( xLim(2)-xLim(1) ) / ( numCols - 1 );
dy = ( yLim(2)-yLim(1) ) / ( numRows - 1 );

[X, Y] = meshgrid( (xLim(1):dx:(xLim(2))), ...
    (yLim(1):dy:(yLim(2))) );

XY = [ X(:), Y(:) ];

end

function XY = generate_equilateral_lattice_points( latticeOptions )

xLim = latticeOptions.xLim;
yLim = latticeOptions.yLim;
L = latticeOptions.sideLength;

if strcmpi(latticeOptions.orientation, 'vertical')

    N = floor(diff(yLim)/L);
    M = floor(diff(xLim)/(sqrt(3) * L / 2));

    A = repmat((-M:0), N, 1);
    B = repmat((0:(N-1)).', 1, M+1);

    Z = (sqrt(3)*pi/N) .* A + ...
        (2i*pi/N) .* ( B + mod(A,2) ./ 2);
    Z = flipud(Z);

    X = real(Z); Y = imag(Z);

    l = Y(end-1, end) - Y(end, end);

    Y = (L/l) .* Y + yLim(1);
    X = (L/l) .* X;
    X = (X - min(X(:))) + xLim(1);

    XY = [X(:), Y(:)];

else

    N = floor(diff(xLim)/L);
    M = floor(diff(yLim)/(sqrt(3) * L / 2));

    A = repmat((-M:0), N, 1);
    B = repmat((0:(N-1)).', 1, M+1);

    Z = 1i*(sqrt(3)*pi/N) .* A + ...
        (2*pi/N) .* ( B + mod(A,2) ./ 2);
    Z = flipud(Z);

    X = real(Z); Y = imag(Z);

    l = X(end-1, end) - X(end, end);

    X = (L/l) .* X + xLim(1);
    Y = (L/l) .* Y;
    Y = (Y-min(Y(:))) + yLim(1);

    XY = [X(:), Y(:)];

end

end

function XY = generate_triangular_lattice_points( latticeOptions )

xLim = latticeOptions.xLim;
yLim = latticeOptions.yLim;
N = latticeOptions.numRows; 
M = latticeOptions.numCols-1; 

A = repmat((-M:0), N, 1);
B = repmat((0:(N-1)).', 1, M+1);

Z = (sqrt(3)*pi/N) .* A + ...
    (2i*pi/N) .* ( B + mod(A,2) ./ 2);

Z = flipud(Z);
X = real(Z(:));
Y = imag(Z(:));

X = X+min(X);
X = diff(xLim) * X ./ max(X) - xLim(1);

Y = Y+min(Y);
Y = diff(yLim) * Y ./ max(Y) - yLim(1);

XY = [X, Y];

end

function XY = generate_uniform_random_points( latticeOptions )

xLim = latticeOptions.xLim;
yLim = latticeOptions.yLim;
numPoints = latticeOptions.numPoints;

X = diff(xLim) .* rand(numPoints, 1) + xLim(1);
Y = diff(yLim) .* rand(numPoints, 1) + yLim(1);

XY = [X, Y];

end

function XY = generate_uniform_random_points_min_dist( latticeOptions )

xLim = latticeOptions.xLim;
yLim = latticeOptions.yLim;
numPoints = latticeOptions.numPoints;

r = latticeOptions.minDist;
k = latticeOptions.maxRandSamples;

% Generate a square grid over the bounding box
% Box side length = r/sqrt(2)
xGridVec = xLim(1):(r/sqrt(2)):xLim(2);
yGridVec = yLim(1):(r/sqrt(2)):yLim(2);
% [boxX, ~] = meshgrid( xGridVec, yGridVec );

% Create an occupancy grid
occupancyGrid = -ones(length(yGridVec), length(xGridVec));
occupancyGrid(:, end) = [];
occupancyGrid(end, :) = [];

% Draw the first random point
XY =  [ (xGridVec(end)-xGridVec(1)) .* rand(1) + xGridVec(1), ...
    (yGridVec(end)-yGridVec(1)) .* rand(1) + yGridVec(1) ];

% Determine the grid box containing the first point
randBoxI = find( yGridVec > XY(2), 1 ) - 1;
randBoxJ = find( xGridVec > XY(1), 1 ) - 1;
occupancyGrid(randBoxI, randBoxJ) = 1;

% Create the active box list
activePoints = 1;

% The running total number of successfully determined points
numPointsFound = 1;

while ((numPointsFound < numPoints) && (numel(activePoints) > 0))
    
    % Pick a random box/point from the active list
    % This will be the base point for choosing the next sample
    curActiveID = randi(numel(activePoints),1); % The ID in the active list order
    curPointID = activePoints(curActiveID); % The ID in the extant point order
    curXY = XY(curPointID, :); % The (x,y)-coordinates of the active point
    
    for i = 1:k
        
        % Draw a random point in an annulus around the current active point
        % that lies within the grid box
        candidateFound = false;
        while ~candidateFound
            
            randR = r * rand(1) + r;
            randT = 2 * pi * rand(1);
            randXY = randR .* [ cos(randT), sin(randT) ] + curXY;
            
            % Determine the grid box containing the candidate point
            randBoxI = find( yGridVec > randXY(2), 1 ) - 1;
            randBoxJ = find( xGridVec > randXY(1), 1 ) - 1;
            
            if ( ~isempty(randBoxI) && ~isempty(randBoxJ) ...
                    && (randBoxI > 0) && (randBoxJ > 0) )
                candidateFound = true;
            end

        end
 
        % Extract the nearby points in the grid
        nearbyIDx = occupancyGrid( ...
            max(1, randBoxI-2):min(size(occupancyGrid,1), randBoxI+2), ...
            max(1, randBoxJ-2):min(size(occupancyGrid,2), randBoxJ+2) );
        nearbyIDx = nearbyIDx(:);
        nearbyIDx = nearbyIDx(nearbyIDx > 0);
        
        % Accept the candidate if no other points lie nearby
        if isempty(nearbyIDx)
            
            numPointsFound = numPointsFound + 1;
            activePoints = [activePoints; numPointsFound];
            XY = [XY; randXY];
            occupancyGrid(randBoxI, randBoxJ) = numPointsFound;
            break;
            
        end

        % Find the distances between the sample and the nearby points
        pairDists = XY(nearbyIDx, :) - repmat(randXY, numel(nearbyIDx), 1);
        pairDists = sqrt(sum(pairDists.^2, 2));
        
        % Accept the candidate if it is sufficiently far from all other
        % points
        if all(pairDists > r)
            
            numPointsFound = numPointsFound + 1;
            activePoints = [activePoints; numPointsFound];
            XY = [XY; randXY];
            occupancyGrid(randBoxI, randBoxJ) = numPointsFound;
            break;
            
        end
        
        % If no candidates meet the criteria remove this base point from
        % the active point list
        if (i == k), activePoints(curActiveID) = []; end

    end    
    
end

if (size(XY,1) ~= numPoints)
    warning('Failed to generate desired number of points');
end

end

function XY = generate_uniform_random_points_min_dist_disk( latticeOptions )

error('This functionality is not yet built');

end

